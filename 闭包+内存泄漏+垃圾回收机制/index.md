## 什么是闭包

### 闭包就是：当一个函数 对外面的属性有使用 那就是一个闭包

```
var age=18
  function fn(){
     console.log(name)
  }
```

#### 以上就是一个 闭包

#### 什么是 内存泄漏呢

```
内存泄漏 就是 因为 只要程序需要运行就 必须提供 内存  当一个栈内存创建出来的属性，或者堆内存里面创建的一个引用类型  如果不使用 则就可能造成内存泄漏 轻则影响系统性能，重则进程崩溃
 比如 var arr=[1,2,3]
 这里就是 arr一直指向一个地址（0xa00）
 ....
 创建之后 从未使用 就有可能 会造成 内存泄漏
   为什么说 闭包  有可能 会出现内存泄漏？

   function fn(){
      let name='席伟蛟', age=18
      function bar(){
         console.log(name,age)
      }
      return bar
   }
   var fun=fn()
   fun()
   以上代码 是怎么 执行的

   先是 创建 执行栈（EC）
   然后创建 全局执行上下文
    VO指向 GO    GO={
      window:GO,
      Date,
      String,
      ....
      fn:内存地址（0x00b）
      fun:内存地址（0x00c）
    }
    接下来在预解析 时候
    fn的内存地址（0x00b）= {
      ParentScopes:GO,
      函数 执行体（函数内部需要执行的代码）
    }
    创建 fn函数的 VO 指向 fn的AO
    此时 还未执行 fn函数 则 fnde AO={
      name:undefined,
      age:undefined,
      bar:0x00c
    }
     此时 执行 fn函数
     当函数进入执行栈后，也会创建一个函数 执行栈
    一般情况下 当函数执行完成之后
    出栈 销毁 AO也销毁
     fn的 AO={
      name:'席伟蛟',
      age:18,
      bar:0x00c
    }
   此时 fn执行结束后出栈销毁  但是 他的AO却没有销毁 那是因为啥呢
 因为     fun=0x00c   执行 fun函数  同样 创建 AO
 fun（0x00c）内存地址= {
      ParentScopes:0x00b(fn的AO地址),
      函数 执行体（函数内部需要执行的代码）
    }
   创建 fun 的AO={

   }
  此时 fun函数执行
   执行       console.log(name,age)
   则会先去 自己的AO里面去找 那么跟age ，没找到 则去 ParentScopes则就是 FO的AO地址（0x00b）
   此时 打印 （'席伟蛟',18）
   因为  fun（0x00c）内存地址中的ParentScopes一直指向FO的AO地址（0x00b）
   所以 无法得到内存释放
   此时 就不得不说到： 垃圾回收机制
    垃圾回收机制：1.引用计数
     let obj={name:"哈哈哈"}
     此时 引用计数就 为1
     obj=2
     此时 引用计数 为0   则这块内存就可以被垃圾回收机制释放了
     还有一个 循环引用  这就是 引用计数的一个漏洞
    var obj1 = {};
    var obj2 = {};
     obj1.a = obj2;  // obj1 引用 obj2
    obj2.a = obj1;  // obj2 引用 obj1
    此时就不会 被回收
    2.标记 - 清除算法
    这个算法假定设置一个叫做根（root）的对象（在 Javascript 里，根是全局对象）。垃圾回收器将定期从根开始，找所有从根开始引用的对象，然后找这些对象引用的对象……从根开始，垃圾回收器将找到所有可以获得的对象和收集所有不能获得的对象。
    如果不是从根对象 中 创建了两个 相互指向的 则就会被垃圾回收机制释放了
    所以 此时 fn:内存地址（0x00b）
      fun:内存地址（0x00c）
      当函数执行完成后 以后 再也不会执行 fun函数时候 ，则 我们只需要将 fun=null
      尽管 fun的0x00c 跟fn的AO相互指向 因为不是从根节点引用出来的 则就会被 垃圾回收机制释放了

```
